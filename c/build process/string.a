!<arch>
string.h/       0           0     0     644     4435      `
#ifndef __STRINGME_H__
#define __STRINGME_H__
#include<stddef.h> /*size_t*/
#include<stdlib.h> /*malloc() free()*/
#include<assert.h> /*assert*/

size_t StrLen(const char* s);


/*
copy string that src points to, including null terminated byte, to the buffer dest points to.
the strings may not overlap! and user has to make sure dest is large enough! !!!BEWARE OF BUFFER OVERRUNS!!!

return value:
pointer to the destination string dest
*/
char *StrCpy(char *dest, const char *src);

/*
similar to strcpy, but at most n byes of src are copied.
-if there is no '\0' among the first n bytes of src, dest will not be null terminated.
-if length of src is less than n, dest will be padded with null terminators so a total of n bytes are written.
return value:
pointer to the destination string dest
*/
char *StrNcpy(char *dest, const char *src, size_t n);

/*
compare two strings
return value:
integer, zero if s1 and s2 are equal.
positive if s1 is bigger lexicographically
negative if s2 is smaller lexicographically
*/
int StrCmp(const char* s1, const char* s2);

/*
similar to strcmp, but the first n bytes are compared.
return value:
integer, zero if s1 and s2 are equal in the first n bytes.
positive if s1 is bigger lexicographically in the first n bytes.
negative if s1 is smaller lexicographically in the first n bytes. 
*/
int StrNcmp(const char *s1, const char *s2, size_t n);

/*
similar to strcmp, but isn't case sensitive.
return value:
integer, zero if s1 and s2 are equal.
positive if s1 is bigger lexicographically.
negative if s1 is smaller lexicographically. 
*/
int StrCasecmp(const char *s1, const char *s2);

/*
The strchr() function returns a pointer to the first occurrence of the character c in the string s.
return value:
a pointer to the matched character or NULL if the character  is  not  found.
The  terminating null byte is considered part of the string, so that if c is specified as '\0', these functions return a pointer to the terminator.
*/
char *StrChr(const char *s, int c);


/*
The  strdup() function returns a pointer to a new string which is a duplicate of the string s.  Memory for the new string is obtained with malloc, and can be freed with free.
return value:
On  success,  the strdup() function returns a pointer to the duplicated string.  It returns NULL if insufficient memory was available
*/
char *StrDup(const char *s);

/*
strcat() function appends the src string to the dest string, overwriting the terminating null byte ('\0') at the end of dest, and  then  adds  a  terminating  null  byte.
strings  may  not  overlap,  and the dest string must have enough space for the result.
return value:
The strcat() and strncat() functions return a pointer to the resulting string dest.
*/
char *StrCat(char *dest, const char *src);

/*
strncat() function appends the src string to the dest string, overwriting the terminating null byte ('\0') at the end of dest, and  then  adds  a  terminating  null  byte.
If  src  contains  n or more bytes, strncat() writes n+1 bytes to dest (n from src plus the terminating null byte).  Therefore, the size of dest must be at least strlen(dest)+n+1.
src does not need to be null-terminated if it contains n or more bytes.
return value:
The strcat() and strncat() functions return a pointer to the resulting string dest.
*/
char *StrNcat(char *dest, const char *src, size_t n);

/*
The  strstr()  function  finds  the  first occurrence of the substring needle in the string haystack.  The terminating null bytes ('\0') are not compared.
return value:
The  strstr()  function  finds  the  first occurrence of the substring needle in the string haystack.  The terminating null bytes ('\0') are not compared.
if needle is empty string the full haystack is returned
*/
char *StrStr(const char *haystack, const char *needle);

/*
The  strspn()  function  calculates the length (in bytes) of the initial segment of s which consists entirely of bytes in accept.
ELIF: 
finds the first occurrence of a character in s that is not contained in the set of characters that is specified by accept.
finds the first occurrence of a character in string1 that is not contained in the set of characters that is specified by accept
'\0' in accept isnt considered in the matching proccess
return value:
the number of bytes in the initial segment of s which consist only of bytes from accept.
*/
size_t StrSpn(const char *s, const char *accept);

#endif /* __STRINGME_H__ */

string1.c/      0           0     0     644     2514      `
#include"string.h"
static int DIFF = 32;

int StrNcmp(const char *s1, const char *s2, size_t n)
{
	int j = 0;
	while (n > 0 && ((*(s1+j) != '\0' || (*(s2+j)) != '\0')))
	{
		if ((*(s1+j)) != (*(s2+j)))
			return (-1 + 2 * ((*(s1+j)) > (*(s2+j))));
		j++;
		n--;
	}
	return 0;
}

int StrCasecmp(const char *s1, const char *s2)
{   
	int j = 0;
	while ((*(s1+j)) != '\0' || (*(s2+j)) != '\0')
	{
		char tmp_s1 = (*(s1+j));
		char tmp_s2 = (*(s2+j));
		if (tmp_s1 >= 'A' && tmp_s1 <= 'Z')
			tmp_s1 += DIFF;	
		if (tmp_s2 >= 'A' && tmp_s2 <= 'Z')
			tmp_s2 += DIFF;
		if (tmp_s1 != tmp_s2)
			return (-1 + 2 * (tmp_s1 > tmp_s2));
		j++;
	}
	return 0;
}

char *StrChr(const char *s, int c)
{
	int i = 0;
	while ((*(s+i)) != (char)c)
	{
		if ((*(s+i)) == '\0')
			return NULL;
		i++;
	}
	return ((char*)(s+i));
}

char *StrDup(const char *s)
{
	size_t s_len = StrLen(s);
	char* new_s = malloc((s_len*sizeof(char))+1);
	if (new_s == NULL)
		return ((char*)NULL);
	StrCpy(new_s, s);
	new_s[s_len] = '\0';
	return new_s;
}

char *StrNcat(char *dest, const char *src, size_t n)
{
	char * dest_start = dest;
	while(*dest)
		dest++;
	assert(*dest == '\0');
	while (n > 0)
	{
		*dest = *src;
		if (*src == '\0')
			return dest_start;
		dest++;
		src++;
		n--;
	}
	*dest = '\0';
	return dest_start;
}

char *StrCat(char *dest, const char *src)
{
	char* dest_start = dest;
	while(*dest)
		dest++;
	assert(*dest == '\0');
	while (*src)
	{
		*dest =*src;
		src++;
		dest++;
	}
	*dest = '\0';
	return dest_start;
}

char *StrStr(const char *haystack, const char *needle)
{
	if (*needle == '\0')
		return (char*)haystack;
	while(*haystack)
	{
		const char * tmp_hay = haystack;
		const char * tmp_needle = needle;
		while(tmp_hay[0] == tmp_needle[0])
		{
			if(*(++tmp_needle) == '\0')
				return (char*)haystack;
			tmp_hay++;
		}
		haystack++;
	}
	return (char*)NULL;
}

size_t StrSpn(const char *s, const char *accept)
{	
	/*not needed
	int method_flag = 0;
	int found_flag = 1;
	*/
	size_t count = 0;
	int dict[256] = {0};
	while(*accept)
	{
		dict[(int)accept[0]] = 1;
		accept++;
	}		
	while(*s)
	{
		if (!dict[(int)s[0]])
			return count;
		s++;
		count++;
	}
	return count;
		
		
		/* not needed
		case 2:
			while(*s && found_flag)
			{
				const char* tmp_accept = accept;
				found_flag = 0;
				while(*tmp_accept)
				{
					if(s[0] == tmp_accept[0])
					{
						found_flag = 1;
						break;
					}
					tmp_accept++;
				}
				if(!found_flag)
					break;
				s++;
				count++;
			}
			return count;
		break;
	}
	*/
}

string2.c/      0           0     0     644     796       `
#include"string.h"

size_t StrLen(const char* s)
{
	size_t count = 0;
	while (s[count] != '\0')
	{
		count++;
	}
	return count;
}

char *StrCpy(char *dest, const char *src)
{
	size_t i = 0;
	while ((*(src+i)) != '\0')
	{
		(*(dest+i)) = (*(src+i));
		i++;
	}
	(*(dest+i)) = '\0';
	return dest;
}

char *StrNcpy(char *dest, const char *src, size_t n)
{
	size_t i = 0;
	int flag = 0;
	for (;i < n; i++)
	{
		if ((*(src+i)) == '\0')
		{
			flag = 1;
			break;		
		}
		(*(dest+i)) = (*(src+i));
	}
	if (flag == 1)
	{
		while (i < n)
		{
			(*(dest+i)) = '\0';
			i++;
		}
	}	
	return dest;
}

int StrCmp(const char* s1, const char* s2)
{
	int j = 0;
	while ((*(s1+j)) != '\0' || (*(s2+j)) != '\0')
	{
		if ((*(s1+j)) != (*(s2+j)))
			return (-1 + 2 * ((*(s1+j)) > (*(s2+j))));
		j++;
	}
	return 0;
}
